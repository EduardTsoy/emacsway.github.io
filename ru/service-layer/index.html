<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml" lang="ru">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Проектирование Сервисного Слоя &mdash; @emacsway&#39;s blog</title>
    
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="author" title="About these documents" href="../../about/" />
    <link rel="top" title="@emacsway&#39;s blog" href="../../" />


   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

    <link rel="shortcut icon" href="../../favicon.ico" type="image/x-icon">
    <link rel="icon" href="../../favicon.ico" type="image/x-icon">


    
        <meta name="description" content="Ошибки проектирования Сервисного Слоя (Service Layer) широко распространены. Эта статья написана в надежде несколько улучшить это положение."> 
    


  </head>
  <body role="document">
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="id1">
<h1><a class="toc-backref" href="#id40">Проектирование Сервисного Слоя</a><a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<p>Ошибки проектирования Сервисного Слоя (<a class="reference external" href="https://martinfowler.com/eaaCatalog/serviceLayer.html">Service Layer</a>) широко распространены.
Эта статья написана в надежде несколько улучшить это положение.</p>
<div class="contents topic" id="id2">
<p class="topic-title first">Содержание</p>
<ul class="simple">
<li><a class="reference internal" href="#id1" id="id40">Проектирование Сервисного Слоя</a></li>
<li><a class="reference internal" href="#id3" id="id41">Назначение Сервисного Слоя</a></li>
<li><a class="reference internal" href="#datamapper" id="id42">Сервис - не обертка для DataMapper</a></li>
<li><a class="reference internal" href="#id17" id="id43">Реализация Сервисного Слоя</a></li>
<li><a class="reference internal" href="#id18" id="id44">Инверсия Управления</a></li>
<li><a class="reference internal" href="#django" id="id45">Распространенная проблема Django-приложений</a></li>
<li><a class="reference internal" href="#id24" id="id46">Укрощение разбухших моделей</a></li>
<li><a class="reference internal" href="#id30" id="id47">Проблема Django-аннотаций</a></li>
<li><a class="reference internal" href="#id31" id="id48">Сервисы инфраструктурного уровня</a></li>
<li><a class="reference internal" href="#id34" id="id49">Что почитать</a></li>
</ul>
</div>
</div>
<div class="section" id="id3">
<h1><a class="toc-backref" href="#id41">Назначение Сервисного Слоя</a><a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h1>
<blockquote>
<div><p>Слой служб определяет границы приложения и множество операций, предоставляемых
им для интерфейсных клиентских слоев кода. Он инкапсулирует бизнес-логику
приложения, управляет транзакциями и координирует реакции надействия.</p>
<p>Defines an application&#8217;s boundary with a layer of services that establishes a set of available
operations and coordinates the application&#8217;s response in each operation.
(«Patterns of Enterprise Application Architecture» <a class="footnote-reference" href="#fnpoeaa" id="id4">[2]</a>)</p>
</div></blockquote>
<blockquote>
<div>SERVICE - An operation offered as an interface that stands alone in the model, with no encapsulated state.
(«Domain-Driven Design: Tackling Complexity in the Heart of Software» <a class="footnote-reference" href="#fnddd" id="id5">[3]</a>)</div></blockquote>
<blockquote>
<div><p>Преимуществом использования слоя служб является возможность определения набора
общих операций, доступных для применения многими категориями клиентов, и координация
откликов приложения на выполнение каждой операции. В сложных случаях
отклики могут включать в себя логику приложения, передаваемую в рамках атомарных
транзакций с использованием нескольких ресурсов. Таким образом, если у бизнес-логики
приложения есть более одной категории клиентов, а отклики на варианты
использования передаются через несколько ресурсов транзакций, использование слоя
служб с транзакциями, управляемыми на уровне контейнера, становится просто необходимым,
даже если архитектура приложения не является распределенной.</p>
<p>The benefit of Service Layer is that it defines a common set of application operations available to many kinds
of clients and it coordinates an application&#8217;s response in each operation. The response may involve application
logic that needs to be transacted atomically across multiple transactional resources. Thus, in an application
with more than one kind of client of its business logic, and complex responses in its use cases involving
multiple transactional resources, it makes a lot of sense to include a Service Layer with container-managed
transactions, even in an undistributed architecture.
(«Patterns of Enterprise Application Architecture» <a class="footnote-reference" href="#fnpoeaa" id="id6">[2]</a>)</p>
</div></blockquote>
<blockquote>
<div><p>Один из общих подходов к реализации бизнес-логики состоит в расщеплении слоя
предметной области на два самостоятельных слоя: &#8220;поверх&#8221; модели предметной области
или модуля таблицы располагается слой служб (Service Layer, 156). Обычно это целесообразно
только при использовании модели предметной области или модуля таблицы, поскольку
слой домена, включающий лишь сценарий транзакции, не настолько сложен,
чтобы заслужить право на создание дополнительного слоя. Логика слоя представления
взаимодействует с бизнес-логикой исключительно при посредничестве слоя служб, который
действует как API приложения.</p>
<p>Поддерживая внятный интерфейс приложения (API), слой служб подходит также для
размещения логики управления транзакциями и обеспечения безопасности. Это дает
возможность снабдить подобными характеристиками каждый метод слоя служб. Для таких
целей обычно применяются файлы свойств, но атрибуты .NET предоставляют удобный
способ описания параметров непосредственно в коде.</p>
<p>A common approach in handling domain logic is to split the domain layer in two. A Service Layer (133) is
placed over an underlying Domain Model (116) or Table Module (125). Usually you only get this with a
Domain Model (116) or Table Module (125) since a domain layer that uses only Transaction Script (110) isn&#8217;t
complex enough to warrant a separate layer. The presentation logic interacts with the domain purely through
the Service Layer (133), which acts as an API for the application.</p>
<p>As well as providing a clear API, the Service Layer (133) is also a good spot to place such things as
transaction control and security. This gives you a simple model of taking each method in the Service Layer
(133) and describing its transactional and security characteristics. A separate properties file is a common
choice for this, but .NET&#8217;s attributes provide a nice way of doing it directly in the code.
(«Patterns of Enterprise Application Architecture» <a class="footnote-reference" href="#fnpoeaa" id="id7">[2]</a>)</p>
</div></blockquote>
<p>Самое главное что следует усвоить, так это то, что Сервисный Слой относится к логике уровня Приложения.
Это важно, поскольку из этого следует, что Сервисный Слой находится выше слоя уровня предметной области (domain logic), т.е. слоя объектов реального мира, который так же называет деловыми регламентами (business rules).
Из этого так же следует и то, что объекты предметной области не должны быть осведомлены о наличии Сервисного Слоя.</p>
<p>Следует обратить внимание на тот факт, что под термином &#8220;business rules&#8221; Eric Evans понимает логику предметной области:</p>
<blockquote>
<div><dl class="docutils">
<dt>User Interface (or Presentation Layer)</dt>
<dd>Responsible for showing information to the user and interpreting the user&#8217;s
commands. The external actor might sometimes be another computer
system rather than a human user.</dd>
<dt>Application Layer</dt>
<dd>Defines the jobs the software is supposed to do and directs the expressive
domain objects to work out problems. The tasks this layer is responsible
for are meaningful to the business or necessary for interaction with the
application layers of other systems.
This layer is kept thin. It <strong>does not contain business rules</strong> or knowledge, but
only coordinates tasks and delegates work to collaborations of domain
objects in the next layer down. It does not have state reflecting the
business situation, but it can have state that reflects the progress of a task
for the user or the program.</dd>
<dt>Domain Layer (or Model Layer)</dt>
<dd>Responsible for representing concepts of the business, information about
the <strong>business situation, and business rules</strong>. State that reflects the business
situation is controlled and used here, even though the technical details of
storing it are delegated to the infrastructure. This layer is the heart of
business software.</dd>
<dt>Infrastructure Layer</dt>
<dd>Provides generic technical capabilities that support the higher layers:
message sending for the application, persistence for the domain, drawing
widgets for the UI, and so on. The infrastructure layer may also support
the pattern of interactions between the four layers through an
architectural framework.</dd>
</dl>
<p>(«Domain-Driven Design: Tackling Complexity in the Heart of Software» <a class="footnote-reference" href="#fnddd" id="id8">[3]</a>)</p>
</div></blockquote>
<p>В то время как Martin Fowler понимает под термином &#8220;business logic&#8221; не только логику предметной области:</p>
<blockquote>
<div><p>Подобно сценарию транзакции (Transaction Script, 133) и модели предметной области
(Domain Model, 140), слой служб представляет собой типовое решение по организации
бизнес-логики. Многие проектировщики, и я в том числе, любят разносить <strong>бизнес-логику</strong>
по двум категориям: логика домена (domain logic) имеет дело только с предметной
областью как таковой (примером могут служить стратегии вычисления зачтенного дохода
по контракту), а логика приложения (application logic) описывает сферу ответственности
приложения [11] (скажем, уведомляет пользователей и сторонние приложения о протекании
процесса вычисления доходов). Логику приложения часто называют также
&#8220;логикой рабочего процесса&#8221;, несмотря на то что под &#8220;рабочим процессом&#8221; часто понимаются
совершенно разные вещи.</p>
<p>Like Transaction Script (110) and Domain Model (116), Service Layer is a pattern for organizing <strong>business logic</strong>.
Many designers, including me, like to divide &#8220;<strong>business logic</strong>&#8221; into two kinds: &#8220;domain logic,&#8221; having to
do purely with the problem domain (such as strategies for calculating revenue recognition on a contract), and
&#8220;application logic,&#8221; having to do with application responsibilities [Cockburn UC] (such as notifying contract
administrators, and integrated applications, of revenue recognition calculations). Application logic is
sometimes referred to as &#8220;workflow logic,&#8221; although different people have different interpretations of
&#8220;workflow.&#8221;
(«Patterns of Enterprise Application Architecture» <a class="footnote-reference" href="#fnpoeaa" id="id9">[2]</a>)</p>
</div></blockquote>
<p>Мы будем рассматривать под термином &#8220;business rules&#8221; (правила делового регламента) исключительно логику предметной области, тем более, что Martin Fowler на это косвенно указывает:</p>
<blockquote>
<div>The problem came with domain logic: business rules, validations, calculations, and
the like.
(«Patterns of Enterprise Application Architecture» <a class="footnote-reference" href="#fnpoeaa" id="id10">[2]</a>)</div></blockquote>
<blockquote>
<div>Then there&#8217;s the matter of what comes under the term &#8220;business logic.&#8221; I find this a curious term because there
are few things that are less logical than business logic.
(«Patterns of Enterprise Application Architecture» <a class="footnote-reference" href="#fnpoeaa" id="id11">[2]</a>)</div></blockquote>
<p>Кроме перечисленного выше, сервисный слой может выполнять следующие обязанности:</p>
<ul class="simple">
<li>Компоновки атомарных операций (например, требуется одновременно сохранить данные в БД, редисе, и на фаловой системе, в рамках одной бизнес-транзакции, или откатить все назад).</li>
<li>Сокрытия источника данных (здесь он дублирует функции паттерна <a class="reference external" href="http://martinfowler.com/eaaCatalog/repository.html">Repository</a>) и может быть опущен, если нет других причин.</li>
<li>Компоновки реиспользуемых операций уровня приложения (например, некая часть логики уровня приложения используется в нескольких различных контроллерах).</li>
<li>Как основа для реализации <a class="reference external" href="https://www.martinfowler.com/eaaCatalog/remoteFacade.html">Интерфейса удаленного доступа</a>.</li>
<li>Когда контроллер имеет какой-то большой метод, он нуждается в декомпозиции, и к нему применяется <a class="reference external" href="https://www.refactoring.com/catalog/extractMethod.html">Extract Method</a> для вычленения обязанностей в отдельные методы. При этом растет количество методов класса, что влечет за собой падение его сфокусированности или <a class="reference external" href="http://wiki.c2.com/?CouplingAndCohesion">Связанности</a> (т.е. коэффициент совместного использования свойств класса его методами). Чтобы восстановить связанность, эти методы выделяются в отдельный класс, образуя <a class="reference external" href="https://www.refactoring.com/catalog/replaceMethodWithMethodObject.html">Method Object</a>. И вот этот метод-объект и может быть преобразован в сервисный слой.</li>
<li>Сервисный слой можно использовать в качестве концентратора запросов, если он стоит поверх паттерна <a class="reference external" href="http://martinfowler.com/eaaCatalog/repository.html">Repository</a> и использует паттерн <a class="reference external" href="http://martinfowler.com/eaaCatalog/queryObject.html">Query object</a>. Дело в том, что паттерн Repository ограничивает свой интерфейс посредством интерфейса Query Object. А так как класс не должен делать предположений о своих клиентах, то накапливать предустановленные запросы в классе <a class="reference external" href="http://martinfowler.com/eaaCatalog/repository.html">Repository</a> нельзя, ибо он не может владеть потребностями всех клиентов. Клиенты должны сами заботиться о себе. А сервисный слой как раз и создан для обслуживания клиентов.</li>
</ul>
<p>В остальных случаях логику сервисного слоя можно размещать прямо на уровне приложения (обычно - контроллер).</p>
<blockquote>
<div><p>Гораздо легче ответить на вопрос, когда слой служб не нужно использовать. Скорее
всего, вам не понадобится слой служб, если у логики приложения есть только одна категория
клиентов, например пользовательский интерфейс, отклики которого на варианты
использования не охватывают несколько ресурсов транзакций. В этом случае управление
транзакциями и выбор откликов можно возложить на контроллеры страниц (Page
Controller, 350), которые будут обращаться непосредственно к слою источника данных.
Тем не менее, как только у вас появится вторая категория клиентов или начнет
использоваться второй ресурс транзакции, вам неизбежно придется ввести слой служб, что
потребует полной переработки приложения.</p>
<p>The easier question to answer is probably when not to use it. You probably don&#8217;t need a Service Layer if your
application&#8217;s business logic will only have one kind of client say, a user interface and its use case responses
don&#8217;t involve multiple transactional resources. In this case your Page Controllers can manually control
transactions and coordinate whatever response is required, perhaps delegating directly to the Data Source
layer.
But as soon as you envision a second kind of client, or a second transactional resource in use case responses, it
pays to design in a Service Layer from the beginning.
(«Patterns of Enterprise Application Architecture» <a class="footnote-reference" href="#fnpoeaa" id="id12">[2]</a>)</p>
</div></blockquote>
<p>Тем не менее, широко распространена точка зрения, что доступ к модели должен всегда производиться через сервисный слой:</p>
<blockquote>
<div><p>Таким образом, на вашем месте я предпочел бы самый тонкий слой служб, какой
только возможен (если он вообще нужен). Обычно же я добавляю его только тогда, когда
он действительно необходим. Впрочем, мне знакомы хорошие специалисты, которые
всегда применяют слой служб, содержащий взвешенную долю бизнес-логики, так что
этим моим советом вы можете благополучно пренебречь.</p>
<p>My preference is thus to have the thinnest Service Layer (133) you can, if you even need one. My usual
approach is to assume that I don&#8217;t need one and only add it if it seems that the application needs it. However, I
know many good designers who always use a Service Layer (133) with a fair bit of logic, so feel free to ignore
me on this one.
(«Patterns of Enterprise Application Architecture» <a class="footnote-reference" href="#fnpoeaa" id="id13">[2]</a>)</p>
</div></blockquote>
<blockquote>
<div><p>Идея вычленения слоя служб из слоя предметной области основана на подходе, пред-
полагающем возможность отмежевания логики процесса от &#8220;чистой&#8221; бизнес-логики.
Уровень служб обычно охватывает логику, которая относится к конкретному варианту
использования системы или обеспечивает взаимодействие с другими инфраструктурами
(например, с помощью механизма сообщений). Стоит ли иметь отдельные слои служб и
предметной области — вопрос, достойный обсуждения. Я склоняюсь к мысли о том, что
подобное решение может оказаться полезным, хотя и не всегда, но некоторые уважае-
мые мною коллеги эту точку зрения не разделяют.</p>
<p>The idea of splitting a services layer from a domain layer is based on a separation of workflow logic from
pure domain logic. The services layer typically includes logic that&#8217;s particular to a single use case and also
some communication with other infrastructures, such as messaging. Whether to have separate services and
domain layers is a matter some debate. I tend to look as it as occasionally useful rather than mandatory, but
designers I respect disagree with me on this.
(«Patterns of Enterprise Application Architecture» <a class="footnote-reference" href="#fnpoeaa" id="id14">[2]</a>)</p>
</div></blockquote>
<blockquote>
<div><p>In some cases, the clearest and most pragmatic design includes operations that do not
conceptually belong to any object. Rather than force the issue, we can follow the natural contours
of the problem space and include SERVICES explicitly in the model.</p>
<p>There are important domain operations that can&#8217;t find a natural home in an ENTITY or VALUE
OBJECT . Some of these are intrinsically activities or actions, not things, but since our modeling
paradigm is objects, we try to fit them into objects anyway...</p>
<p>A SERVICE is an operation offered as an interface that stands alone in the model, without
encapsulating state, as ENTITIES and VALUE OBJECTS do. S ERVICES are a common pattern in technical
frameworks, but they can also apply in the domain layer.</p>
<p>The name service emphasizes the relationship with other objects. Unlike ENTITIES and VALUE
OBJECTS , it is defined purely in terms of what it can do for a client. A SERVICE tends to be named for
an activity, rather than an entity—a verb rather than a noun. A SERVICE can still have an abstract,
intentional definition; it just has a different flavor than the definition of an object. A SERVICE should
still have a defined responsibility, and that responsibility and the interface fulfilling it should be
defined as part of the domain model. Operation names should come from the UBIQUITOUS
LANGUAGE or be introduced into it. Parameters and results should be domain objects.</p>
<p>SERVICES should be used judiciously and not allowed to strip the ENTITIES and VALUE OBJECTS of all
their behavior. But when an operation is actually an important domain concept, a SERVICE forms a
natural part of a MODEL-DRIVEN DESIGN . Declared in the model as a SERVICE, rather than as a
phony object that doesn&#8217;t actually represent anything, the standalone operation will not mislead
anyone.</p>
<p>A good SERVICE has three characteristics.</p>
<p>1. The operation relates to a domain concept that is not a natural part of an ENTITY or VALUE
OBJECT .
2. The interface is defined in terms of other elements of the domain model.
3. The operation is stateless.</p>
<p>Statelessness here means that any client can use any instance of a particular SERVICE without
regard to the instance&#8217;s individual history. The execution of a SERVICE will use information that is
accessible globally, and may even change that global information (that is, it may have side
effects). But the SERVICE does not hold state of its own that affects its own behavior, as most
domain objects do.</p>
<p>When a significant process or transformation in the domain is not a natural
responsibility of an ENTITY or VALUE OBJECT , add an operation to the model as a
standalone interface declared as a SERVICE . Define the interface in terms of the
language of the model and make sure the operation name is part of the UBIQUITOUS
LANGUAGE . Make the SERVICE stateless.
(«Domain-Driven Design: Tackling Complexity in the Heart of Software» <a class="footnote-reference" href="#fnddd" id="id15">[3]</a>)</p>
</div></blockquote>
</div>
<div class="section" id="datamapper">
<h1><a class="toc-backref" href="#id42">Сервис - не обертка для DataMapper</a><a class="headerlink" href="#datamapper" title="Permalink to this headline">¶</a></h1>
<p>Часто <a class="reference external" href="https://martinfowler.com/eaaCatalog/serviceLayer.html">Service Layer</a> ошибочно делают как враппер над <a class="reference external" href="http://martinfowler.com/eaaCatalog/dataMapper.html">DataMapper</a>.
Это не совсем верно.
Маппер обслуживает Domain (объект предметной области), а сервисный слой обслуживает клиента (группу клиентов).
Сервисный слой может манипулировать в рамках бизнес-транзакции или в интересах клиента несколькими маперами и другими сервисами.
Поэтому методы сервиса обычно содержат имя возвращаемого домена в качестве суффикса (например, getUser()), в то время как методы маппера в этом суффиксе не нуждается (так как имя домена присутствует в имени класса маппера, и маппер обслуживает только один домен).</p>
<blockquote>
<div><p>Установить, какие операции должны быть размещены в слое служб, отнюдь не сложно.
Это определяется нуждами клиентов слоя служб, первой (и наиболее важной) из
которых обычно является пользовательский интерфейс.</p>
<p>Identifying the operations needed on a Service Layer boundary is pretty straightforward. They&#8217;re determined
by the needs of Service Layer clients, the most significant (and first) of which is typically a user interface.
(«Patterns of Enterprise Application Architecture» <a class="footnote-reference" href="#fnpoeaa" id="id16">[2]</a>)</p>
</div></blockquote>
</div>
<div class="section" id="id17">
<h1><a class="toc-backref" href="#id43">Реализация Сервисного Слоя</a><a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h1>
<p>Некоторые примеры реализации:</p>
<ul class="simple">
<li><a class="reference external" href="https://github.com/in2it/zfdemo/blob/master/application/modules/user/services/User.php">https://github.com/in2it/zfdemo/blob/master/application/modules/user/services/User.php</a></li>
<li><a class="reference external" href="https://framework.zend.com/manual/2.4/en/in-depth-guide/services-and-servicemanager.html">https://framework.zend.com/manual/2.4/en/in-depth-guide/services-and-servicemanager.html</a></li>
<li><a class="reference external" href="https://framework.zend.com/manual/2.4/en/user-guide/database-and-models.html#using-servicemanager-to-configure-the-table-gateway-and-inject-into-the-albumtable">https://framework.zend.com/manual/2.4/en/user-guide/database-and-models.html#using-servicemanager-to-configure-the-table-gateway-and-inject-into-the-albumtable</a></li>
<li><a class="reference external" href="https://github.com/zendframework/zf2-tutorial/blob/master/module/Album/src/Album/Model/AlbumTable.php">https://github.com/zendframework/zf2-tutorial/blob/master/module/Album/src/Album/Model/AlbumTable.php</a></li>
</ul>
</div>
<div class="section" id="id18">
<h1><a class="toc-backref" href="#id44">Инверсия Управления</a><a class="headerlink" href="#id18" title="Permalink to this headline">¶</a></h1>
<p>Используйте инверсию управления, желательно в виде &#8220;Пассивного внедрения зависимостей&#8221; <a class="footnote-reference" href="#fnccode" id="id19">[1]</a>, <a class="reference external" href="https://martinfowler.com/articles/injection.html">Dependency Injection</a> Principle (DIP).</p>
<blockquote>
<div><p>Истинное внедрение зависимостей идет еще на один шаг вперед. Класс не
предпринимает непосредственных действий по разрешению своих зависимостей;
он остается абсолютно пассивным. Вместо этого он предоставляет set-методы
и/или аргументы конструктора, используемые для внедрения зависимостей.
В процессе конструирования контейнер DI создает экземпляры необходимых
объектов (обычно по требованию) и использует аргументы конструктора или
set-методы для скрепления зависимостей. Фактически используемые
зависимые объекты задаются в конфигурационном файле или на программном уровне
в специализированном конструирующем модуле.</p>
<p>True Dependency Injection goes one step further. The class takes no direct steps to
resolve its dependencies; it is completely passive. Instead, it provides setter methods or
constructor arguments (or both) that are used to inject the dependencies. During the con-
struction process, the DI container instantiates the required objects (usually on demand)
and uses the constructor arguments or setter methods provided to wire together the depen-
dencies. Which dependent objects are actually used is specified through a configuration
file or programmatically in a special-purpose construction module.
«Clean Code: A Handbook of Agile Software Craftsmanship» <a class="footnote-reference" href="#fnccode" id="id20">[1]</a></p>
</div></blockquote>
<p>Одна из основных обязанностей Сервисного Слоя - это сокрытие источника данных.
Для тестирования можно использовать фиктивный Сервис (<a class="reference external" href="https://martinfowler.com/eaaCatalog/serviceStub.html">Service Stub</a>).
Этот же прием можно использовать для параллельной разработки, когда реализация сервисного слоя еще не готова.
Иногда бывает полезно подменить Сервис генератором фэйковых данных.
В общем, пользы от сервисного слоя будет мало, если нет возможности его подменить (или подменить используемые им зависимости).</p>
</div>
<div class="section" id="django">
<h1><a class="toc-backref" href="#id45">Распространенная проблема Django-приложений</a><a class="headerlink" href="#django" title="Permalink to this headline">¶</a></h1>
<p>Широко распространенная ошибка - использование класса django.db.models.Manager (а то и django.db.models.Model) в качестве сервисного слоя.
Нередко можно встретить, как какой-то метод класса django.db.models.Model принимает в качестве аргумента объект HTTP-запроса django.http.request.HttpRequest, например, для проверки прав.</p>
<p>Объект HTTP-запроса - это логика уровня приложения (application), в то время как класс модели - это логика уровня предметной области (domain), т.е. объекты реального мира, которую так же называют правилами делового регламента (business rules).</p>
<p>Нижележащий слой не должен ничего знать о вышестоящем слое.
Логика уровня домена не должна быть осведомлена о логике уровня приложения.</p>
<p>Классу django.db.models.Manager более всего соответствует класс Finder описанный в «Patterns of Enterprise Application Architecture» <a class="footnote-reference" href="#fnpoeaa" id="id21">[2]</a>.</p>
<blockquote>
<div><p>При реализации шлюза записи данных возникает вопрос: куда &#8220;пристроить&#8221; методы
поиска, генерирующие экземпляр данного типового решения? Разумеется, можно
воспользоваться статическими методами поиска, однако они исключают возможность
полиморфизма (что могло бы пригодиться, если понадобится определить разные методы
поиска для различных источников данных). В подобной ситуации часто имеет смысл
создать отдельные объекты поиска, чтобы у каждой таблицы реляционной базы данных
был один класс для проведения поиска и один класс шлюза для сохранения результатов
этого поиска.</p>
<p>Иногда шлюз записи данных трудно отличить от активной записи (Active Record, 182).
В этом случае следует обратить внимание на наличие какой-либо логики домена; если
она есть, значит, это активная запись. Реализация шлюза записи данных должна включать
в себя только логику доступа к базе данных и никакой логики домена.</p>
<p>With a Row Data Gateway you&#8217;re faced with the questions of where to put the find operations that generate this
pattern. You can use static find methods, but they preclude polymorphism should you want to substitute
different finder methods for different data sources. In this case it often makes sense to have separate finder
objects so that each table in a relational database will have one finder class and one gateway class for the results.</p>
<p>It&#8217;s often hard to tell the difference between a Row Data Gateway and an Active Record (160). The crux of the
matter is whether there&#8217;s any domain logic present; if there is, you have an Active Record (160). A Row Data
Gateway should contain only database access logic and no domain logic.
(Chapter 10. &#8220;Data Source Architectural Patterns : Row Data Gateway&#8221;, «Patterns of Enterprise Application Architecture» <a class="footnote-reference" href="#fnpoeaa" id="id22">[2]</a>)</p>
</div></blockquote>
<p>Хотя Django не использует паттерн <a class="reference external" href="http://martinfowler.com/eaaCatalog/repository.html">Repository</a>, она использует абстракцию критериев выборки, своего рода разновидность паттерна <a class="reference external" href="http://martinfowler.com/eaaCatalog/queryObject.html">Query Object</a>.
Подобно паттерну Repository, класс модели (<a class="reference external" href="http://www.martinfowler.com/eaaCatalog/activeRecord.html">ActiveRecord</a>) ограничивает свой интерфейс посредством интерфейса Query Object.
Клиенты должны пользоваться предоставленным интерфейсом, а не возлагать на модель и ее менеджер свои обязанности по знанию своих запросов.
А так как никакой класс не должен делать предположений о своих клиентах, то накапливать предустановленные запросы в классе модели нельзя, ибо он не может владеть потребностями всех клиентов.
Клиенты должны сами заботиться о себе.
А сервисный слой как раз и создан для обслуживания клиентов.</p>
<p>Попытки исключить Сервинсый Слой из Django-приложений приводит к появлению менеджеров с огромным количеством методов.</p>
<p>Хорошей практикой было бы сокрытие посредством сервисного слоя способа реализации Django моделей в виде <a class="reference external" href="http://www.martinfowler.com/eaaCatalog/activeRecord.html">ActiveRecord</a>.
Это позволит безболезненно подменить ORM в случае необходимости.</p>
<blockquote>
<div><p>Можно было бы поспорить и о размещении логики приложения. Думаю, некоторые
предпочли бы реализовать ее в методах объектов домена, таких, как
Contract. calculateRevenueRecognitions (), ИЛИ вообще В слое источника данных, ЧТО
позволило бы обойтись без отдельного слоя служб. Тем не менее подобное размещение
логики приложения кажется мне весьма нежелательным, и вот почему. Во-первых, классы
объектов домена, которые реализуют логику, специфичную для приложения (и зависят
от шлюзов и других объектов, специфичных для приложения), менее подходят для
повторного использования другими приложениями. Это должны быть модели частей
предметной области, представляющих интерес для данного приложения, поэтому подобные
объекты вовсе не обязаны описывать возможные отклики на все варианты использования
приложения. Во-вторых, инкапсуляция логики приложения на более высоком
уровне (каковым не является слой источника данных) облегчает изменение реализации
этого слоя, возможно, посредством некоторых специальных инструментальных средств.</p>
<p>Some might also argue that the application logic responsibilities could be implemented in domain object
methods, such as Contract.calculateRevenueRecognitions(), or even in the data source layer,
thereby eliminating the need for a separate Service Layer. However, I find those allocations of responsibility
undesirable for a number of reasons. First, domain object classes are less reusable across applications if they
implement application-specific logic (and depend on application-specific Gateways (466), and the like). They
should model the parts of the problem domain that are of interest to the application, which doesn&#8217;t mean all of
application&#8217;s use case responsibilities. Second, encapsulating application logic in a &#8220;higher&#8221; layer
dedicated to that purpose (which the data source layer isn&#8217;t) facilitates changing the implementation of that
layer perhaps to use a workflow engine.
(«Patterns of Enterprise Application Architecture» <a class="footnote-reference" href="#fnpoeaa" id="id23">[2]</a>)</p>
</div></blockquote>
</div>
<div class="section" id="id24">
<h1><a class="toc-backref" href="#id46">Укрощение разбухших моделей</a><a class="headerlink" href="#id24" title="Permalink to this headline">¶</a></h1>
<p>Часто можно встретить модели имеющие больше число методов (я встречал несколько сотен).
При анализе таких моделей часто обнаруживаются посторонние обязанности в классе, а размер класса, как известно, измеряется количеством его обязанностей.
Все обязанности, которые не относятся к Доменной области, следует вынести в Сервисный Слой.
Но что делать с другими методами?</p>
<p>Предположим, некая Модель имеет несколько десятков методов, которые не имеют общего применения, а используются только одним клиентом.
Отнести их к обязанности клиентов нельзя, так как это привело бы к появлению &#8220;G14: Feature Envy&#8221; <a class="footnote-reference" href="#fnccode" id="id25">[1]</a>.</p>
<p>Как уже упоминалось ранее, Service Layer обычно реализуется как объект без состояния.
Если клиент относится к логике Приложения, то решением может быть создание Service Layer.</p>
<blockquote>
<div><p>Модель предметной области более предпочтительна в сравнении со сценарием транзакции,
поскольку исключает возможность дублирования бизнес-логики и позволяет
бороться со сложностью с помощью классических проектных решений. Но размещение
логики приложения в &#8220;чистых&#8221; классах домена чревато нежелательными последствиями.
Во-первых, классы домена допускают меньшую вероятность повторного использования,
если они реализуют специфическую логику приложения и зависят от тех или иных прикладных
инструментальных пакетов. Во-вторых, смешивание логики обеих категорий
в контексте одних и тех же классов затрудняет возможность новой реализации логики
приложения с помощью специфических инструментальных средств, если необходимость
такого шага становится очевидной. По этим причинам слой служб предусматривает
распределение &#8220;разной&#8221; логики по отдельным слоям, что обеспечивает традиционные
преимущества расслоения, а также большую степень свободы применения классов домена
в разных приложениях.</p>
<p>Domain Models (116) are preferable to Transaction Scripts (110) for avoiding domain logic duplication and
for managing complexity using classical design patterns. But putting application logic into pure domain object
classes has a couple of undesirable consequences. First, domain object classes are less reusable across
applications if they implement application-specific logic and depend on application-specific packages.
Second, commingling both kinds of logic in the same classes makes it harder to reimplement the application
logic in, say, a workflow tool if that should ever become desirable. For these reasons Service Layer factors
each kind of business logic into a separate layer, yielding the usual benefits of layering and rendering the pure
domain object classes more reusable from application to application.
(«Patterns of Enterprise Application Architecture» <a class="footnote-reference" href="#fnpoeaa" id="id26">[2]</a>)</p>
</div></blockquote>
<p>Но если клиент относится к логике Доменной области, то нельзя допустить чтобы слой уровня Доменной логики был осведомлен о логике Приложения.
А Service Layer - это логика уровня приложения.</p>
<p>Иными словами, клиент требует от Доменной Модели интерфейс, который не должен быть реализован Доменной Моделью.
Для выравнивания интерфейсов существует паттерн Adapter (aka Wrapper), см. «Design Patterns Elements of Reusable Object-Oriented Software» <a class="footnote-reference" href="#fngof" id="id27">[4]</a>.</p>
<p>Иными словами, это враппер над инстанцией Модели, который оборачивает её и придает ей дополнительное поведение, которое требуется клиентом. Иногда такие обертки ошибочно называют Аспектом или Декоратором, но это неверно, так как они не изменяют интерфейса оригинального объекта.</p>
<p>Вернемся к случаю, когда клиент относится к логике Приложения. Можно ли применять паттерн Adapter в этом случае?</p>
<p>Martin Fowler говорит что:</p>
<blockquote>
<div><p>Двумя базовыми вариантами реализации слоя служб являются создание интерфейса
доступа к домену (domain facade) и конструирование сценария операции (operation script).
При использовании подхода, связанного с интерфейсом доступа к домену, слой служб
реализуется как набор &#8220;тонких&#8221; интерфейсов, размещенных &#8220;поверх&#8221; модели предметной
области. В классах, реализующих интерфейсы, никакая бизнес-логика отражения не
находит — она сосредоточена исключительно в контексте модели предметной области.
Тонкие интерфейсы устанавливают границы и определяют множество операций, посредством
которых клиентские слои взаимодействуют с приложением, обнаруживая тем самым
характерные свойства слоя служб.</p>
<p>Создавая сценарий операции, вы реализуете слой служб как множество более &#8220;толстых&#8221;
классов, которые непосредственно воплощают в себе логику приложения, но за бизнес-логикой
обращаются к классам домена. Операции, предоставляемые клиентам слоя
служб, реализуются в виде сценариев, создаваемых группами в контексте классов, каждый
из которых определяет некоторый фрагмент соответствующей логики. Подобные
классы, расширяющие супертип слоя (Layer Supertype, 491) и уточняющие объявленные
в нем абстрактные характеристики поведения и сферы ответственности, формируют &#8220;службы&#8221;
приложения (в названиях служебных типов принято употреблять суффикс &#8220;Service&#8221;).
Слой служб и заключает в себе эти прикладные классы.</p>
<p>The two basic implementation variations are the domain facade approach and the operation script approach. In
the domain facade approach a Service Layer is implemented as a set of thin facades over a Domain Model
(116). The classes implementing the facades don&#8217;t implement any business logic. Rather, the Domain Model
(116) implements all of the business logic. The thin facades establish a boundary and set of operations through
which client layers interact with the application, exhibiting the defining characteristics of Service Layer.</p>
<p>In the operation script approach a Service Layer is implemented as a set of thicker classes that directly
implement application logic but delegate to encapsulated domain object classes for domain logic. The
operations available to clients of a Service Layer are implemented as scripts, organized several to a class
defining a subject area of related logic. Each such class forms an application &#8220;service,&#8221; and it&#8217;s common for
service type names to end with &#8220;Service.&#8221; A Service Layer is comprised of these application service classes,
which should extend a Layer Supertype (475), abstracting their responsibilities and common behaviors.
(«Patterns of Enterprise Application Architecture» <a class="footnote-reference" href="#fnpoeaa" id="id28">[2]</a>)</p>
</div></blockquote>
<p>Поскольку Martin Fowler прекрасно понимает отличие между &#8220;<a class="reference external" href="https://martinfowler.com/eaaCatalog/domainModel.html">Domain Model</a>&#8221; и &#8220;<a class="reference external" href="http://martinfowler.com/eaaCatalog/dataMapper.html">DataMapper</a>&#8221;,
эта цитата сильно напоминает мне &#8220;Cross-Cutting Concerns&#8221; <a class="footnote-reference" href="#fnccode" id="id29">[1]</a> с тем только отличием, что &#8220;Cross-Cutting Concerns&#8221; реализует интерфейс оригинального объекта, в то время как domain facade дополняет его.</p>
</div>
<div class="section" id="id30">
<h1><a class="toc-backref" href="#id47">Проблема Django-аннотаций</a><a class="headerlink" href="#id30" title="Permalink to this headline">¶</a></h1>
<p>Я часто наблюдал такую проблему, когда в Django Model добавлялось какое-то новое поле, и начинали сыпаться проблемы, так как это имя уже было использовано либо с помощью аннотаций, либо с помощью Raw-SQL.
Storm ORM/SQLAlchemy, реализуют аннотации более удачно.
Если Вам все-таки пришлось работать с Django ORM, воздержитесь от использования механизма Django аннотаций в пользу голого паттерна <a class="reference external" href="http://martinfowler.com/eaaCatalog/dataMapper.html">DataMapper</a>.</p>
</div>
<div class="section" id="id31">
<h1><a class="toc-backref" href="#id48">Сервисы инфраструктурного уровня</a><a class="headerlink" href="#id31" title="Permalink to this headline">¶</a></h1>
<p>От сервисного слоя следует отличать сервисы инфраструктурного уровня.</p>
<blockquote>
<div><p>The infrastructure layer usually does not initiate action in the domain layer. Being &#8220;below&#8221; the
domain layer, it should have no specific knowledge of the domain it is serving. Indeed, such
technical capabilities are most often offered as SERVICES . For example, if an application needs to
send an e-mail, some message-sending interface can be located in the infrastructure layer and the
application layer elements can request the transmission of the message. This decoupling gives
some extra versatility. The message-sending interface might be connected to an e-mail sender, a
fax sender, or whatever else is available. But the main benefit is simplifying the application layer,
keeping it narrowly focused on its job: knowing when to send a message, but not burdened with
how.</p>
<p>The application and domain layers call on the SERVICES provided by the infrastructure layer. When
the scope of a SERVICE has been well chosen and its interface well designed, the caller can remain
loosely coupled and uncomplicated by the elaborate behavior the SERVICE interface encapsulates.</p>
<p>But not all infrastructure comes in the form of SERVICES callable from the higher layers. Some
technical components are designed to directly support the basic functions of other layers (such as
providing an abstract base class for all domain objects) and provide the mechanisms for them to
relate (such as implementations of MVC and the like). Such an &#8220;architectural framework&#8221; has
much more impact on the design of the other parts of the program.
(«Domain-Driven Design: Tackling Complexity in the Heart of Software» <a class="footnote-reference" href="#fnddd" id="id32">[3]</a>)</p>
</div></blockquote>
<blockquote>
<div>Infrastructure Layer - Provides generic technical capabilities that support the higher layers:
message sending for the application, persistence for the domain, drawing
widgets for the UI, and so on. The infrastructure layer may also support
the pattern of interactions between the four layers through an
architectural framework.
(«Domain-Driven Design: Tackling Complexity in the Heart of Software» <a class="footnote-reference" href="#fnddd" id="id33">[3]</a>)</div></blockquote>
</div>
<div class="section" id="id34">
<h1><a class="toc-backref" href="#id49">Что почитать</a><a class="headerlink" href="#id34" title="Permalink to this headline">¶</a></h1>
<ul>
<li><dl class="first docutils">
<dt>«Clean Code: A Handbook of Agile Software Craftsmanship» by Robert C. Martin <a class="footnote-reference" href="#fnccode" id="id35">[1]</a>, главы:</dt>
<dd><ul class="first last simple">
<li>Dependency Injection ... 157</li>
<li>Cross-Cutting Concerns ... 160</li>
<li>Java Proxies ... 161</li>
<li>Pure Java AOP Frameworks ... 163</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>«Patterns of Enterprise Application Architecture» by Martin Fowler <a class="footnote-reference" href="#fnpoeaa" id="id36">[2]</a>, главы:</dt>
<dd><ul class="first last simple">
<li>Part 1. The Narratives : Chapter 2. Organizing Domain Logic : Service Layer</li>
<li>Part 1. The Narratives : Chapter 8. Putting It All Together</li>
<li>Part 2. The Patterns : Chapter 9. Domain Logic Patterns : Service Layer</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>«Domain-Driven Design: Tackling Complexity in the Heart of Software» by Eric Evans <a class="footnote-reference" href="#fnddd" id="id37">[3]</a>, глава:</dt>
<dd><ul class="first last simple">
<li>Part II: The Building Blocks of a Model-Driven Design : Chapter Five. A Model Expressed in Software : Services</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>«Design Patterns Elements of Reusable Object-Oriented Software» by Erich Gamma <a class="footnote-reference" href="#fngof" id="id38">[4]</a>, главы:</dt>
<dd><ul class="first last simple">
<li>Design Pattern Catalog : 4 Structural Patterns : Adapter ... 139</li>
<li>Design Pattern Catalog : 4 Structural Patterns : Decorator ... 175</li>
</ul>
</dd>
</dl>
</li>
</ul>
<p>This article in English &#8220;<a class="reference internal" href="../../en/service-layer/"><span class="doc">Design of Service Layer</span></a>&#8221;.</p>
<p class="rubric">Footnotes</p>
<table class="docutils footnote" frame="void" id="fnccode" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id19">1</a>, <a class="fn-backref" href="#id20">2</a>, <a class="fn-backref" href="#id25">3</a>, <a class="fn-backref" href="#id29">4</a>, <a class="fn-backref" href="#id35">5</a>)</em> «<a class="reference external" href="http://www.informit.com/store/clean-code-a-handbook-of-agile-software-craftsmanship-9780132350884">Clean Code: A Handbook of Agile Software Craftsmanship</a>» by <a class="reference external" href="http://informit.com/martinseries">Robert C. Martin</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="fnpoeaa" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td><em>(<a class="fn-backref" href="#id4">1</a>, <a class="fn-backref" href="#id6">2</a>, <a class="fn-backref" href="#id7">3</a>, <a class="fn-backref" href="#id9">4</a>, <a class="fn-backref" href="#id10">5</a>, <a class="fn-backref" href="#id11">6</a>, <a class="fn-backref" href="#id12">7</a>, <a class="fn-backref" href="#id13">8</a>, <a class="fn-backref" href="#id14">9</a>, <a class="fn-backref" href="#id16">10</a>, <a class="fn-backref" href="#id21">11</a>, <a class="fn-backref" href="#id22">12</a>, <a class="fn-backref" href="#id23">13</a>, <a class="fn-backref" href="#id26">14</a>, <a class="fn-backref" href="#id28">15</a>, <a class="fn-backref" href="#id36">16</a>)</em> «<a class="reference external" href="https://www.martinfowler.com/books/eaa.html">Patterns of Enterprise Application Architecture</a>» by <a class="reference external" href="https://martinfowler.com/aboutMe.html">Martin Fowler</a>, David Rice, Matthew Foemmel, Edward Hieatt, Robert Mee, Randy Stafford</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="fnddd" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[3]</td><td><em>(<a class="fn-backref" href="#id5">1</a>, <a class="fn-backref" href="#id8">2</a>, <a class="fn-backref" href="#id15">3</a>, <a class="fn-backref" href="#id32">4</a>, <a class="fn-backref" href="#id33">5</a>, <a class="fn-backref" href="#id37">6</a>)</em> «Domain-Driven Design: Tackling Complexity in the Heart of Software» by Eric Evans</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="fngof" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[4]</td><td><em>(<a class="fn-backref" href="#id27">1</a>, <a class="fn-backref" href="#id38">2</a>)</em> «Design Patterns Elements of Reusable Object-Oriented Software» by Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides, 1994</td></tr>
</tbody>
</table>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../">
    <img class="logo" src="../../_static/logo.jpg" alt="Logo"/>
    
    <h1 class="logo logo-name">@emacsway's blog</h1>
    
  </a>
</p>









  
  
  <h2>
  
  <i class="fa fa-calendar"></i>
    Jul 17, 2017
  
  </h2>

  <ul>
    

  
  <li><i class="fa-fw fa fa-user"></i>
    
      
      <a href="../../blog/author/ivan-zakrevsky/">Ivan Zakrevsky</a>
      
    </li>
  

  

  
  <li><i class="fa-fw fa fa-language"></i>
    
      
      <a href="../../blog/language/russian/">Russian</a>
      
    </li>
  

  

  
  <li><i class="fa-fw fa fa-tags"></i>
      
    
      
      <a href="../../blog/tag/design/">Design</a>,
      
    
      
      <a href="../../blog/tag/architecture/">Architecture</a>
      
    </li>
  
  
  <li>
    <script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'emacsway'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function () {
    var s = document.createElement('script'); s.async = true;
    s.type = 'text/javascript';
    s.src = 'https://' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
    </script>
    <i class="fa-fw fa fa-comments"></i>
    <a href="#disqus_thread" data-disqus-identifier="/ru/service-layer/"> </a>
  </li>
  
  </ul>


<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../about/">About me</a></li>
</ul>


  <h3><a href="../../blog/">Recent Posts</a></h3>
  <ul>
    
    
      <li><a href="../../en/how-to-quickly-develop-high-quality-code/">Jul 10 - How to quickly develop high-quality code. Team work.</a></li>
    
      <li><a href="../how-to-add-new-operators-for-python-expression/">Sep 08 - Как добавить новые операторы для Python выражений</a></li>
    
      <li><a href="../../en/useful-links/">Aug 29 - Usefull links</a></li>
    
      <li><a href="../martial-way/">Aug 21 - Искусство воевать</a></li>
    
      <li><a href="../cache-dependencies/">May 21 - О проблемах инвалидации кэша. Тегирование кэша.</a></li>
    
  </ul>

  <h3><a href="../../blog/tag/">Tags</a></h3>
  <style type="text/css">
    ul.ablog-cloud {list-style: none; overflow: auto;}
    ul.ablog-cloud li {float: left; height: 20pt; line-height: 18pt; margin-right: 5px;}
    ul.ablog-cloud a {text-decoration: none; vertical-align: middle;}
    li.ablog-cloud-1{font-size: 80%;}
    li.ablog-cloud-2{font-size: 95%;}
    li.ablog-cloud-3{font-size: 110%;}
    li.ablog-cloud-4{font-size: 125%;}
    li.ablog-cloud-5{font-size: 140%;}
  </style>
  <ul class="ablog-cloud">
    
      
      <li class="ablog-cloud ablog-cloud-1">
        <a href="../../blog/tag/architecture/">Architecture</a></li>
      
    
      
      <li class="ablog-cloud ablog-cloud-3">
        <a href="../../blog/tag/db/">DB</a></li>
      
    
      
      <li class="ablog-cloud ablog-cloud-2">
        <a href="../../blog/tag/datamapper/">DataMapper</a></li>
      
    
      
      <li class="ablog-cloud ablog-cloud-1">
        <a href="../../blog/tag/dependency-injection/">Dependency Injection</a></li>
      
    
      
      <li class="ablog-cloud ablog-cloud-1">
        <a href="../../blog/tag/design/">Design</a></li>
      
    
      
      <li class="ablog-cloud ablog-cloud-1">
        <a href="../../blog/tag/emacs/">Emacs</a></li>
      
    
      
      <li class="ablog-cloud ablog-cloud-1">
        <a href="../../blog/tag/fowler/">Fowler</a></li>
      
    
      
      <li class="ablog-cloud ablog-cloud-2">
        <a href="../../blog/tag/orm/">ORM</a></li>
      
    
      
      <li class="ablog-cloud ablog-cloud-5">
        <a href="../../blog/tag/python/">Python</a></li>
      
    
      
      <li class="ablog-cloud ablog-cloud-3">
        <a href="../../blog/tag/sql/">SQL</a></li>
      
    
      
      <li class="ablog-cloud ablog-cloud-2">
        <a href="../../blog/tag/storm-orm/">Storm ORM</a></li>
      
    
      
    
      
      <li class="ablog-cloud ablog-cloud-1">
        <a href="../../blog/tag/autocomplete/">autocomplete</a></li>
      
    
      
      <li class="ablog-cloud ablog-cloud-1">
        <a href="../../blog/tag/cache/">cache</a></li>
      
    
      
      <li class="ablog-cloud ablog-cloud-1">
        <a href="../../blog/tag/programming/">programming</a></li>
      
    
      
      <li class="ablog-cloud ablog-cloud-1">
        <a href="../../blog/tag/refactoring/">refactoring</a></li>
      
    
  </ul>

  <h3><a href="../../blog/archive/">Archives</a></h3>
  <ul>
  
    
    <li><a href="../../blog/2017/">2017 (2)</a></li>
    
  
    
    <li><a href="../../blog/2016/">2016 (5)</a></li>
    
  
    
    <li><a href="../../blog/2015/">2015 (6)</a></li>
    
  
  </ul>

<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search/" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>


    <div class="footer">
      &copy;2017, Ivan Zakrevsky.
      
      |
      Powered by <a href="http://ablog.readthedocs.org/">ABlog</a> &amp; <a href="http://sphinx-doc.org/">Sphinx 1.4.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.8</a>
      
      |
      <a href="../../_sources/ru/service-layer.txt"
          rel="nofollow">Page source</a>
    </div>

    

    


<!-- google.com/analytics counter -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-69288289-1', 'auto');
  ga('send', 'pageview');

</script>
<!-- /google.com/analytics counter -->


<!-- Yandex.Metrika counter -->
<script type="text/javascript">
    (function (d, w, c) {
        (w[c] = w[c] || []).push(function() {
            try {
                w.yaCounter32948409 = new Ya.Metrika({
                    id:32948409,
                    clickmap:true,
                    trackLinks:true,
                    accurateTrackBounce:true
                });
            } catch(e) { }
        });

        var n = d.getElementsByTagName("script")[0],
            s = d.createElement("script"),
            f = function () { n.parentNode.insertBefore(s, n); };
        s.type = "text/javascript";
        s.async = true;
        s.src = "https://mc.yandex.ru/metrika/watch.js";

        if (w.opera == "[object Opera]") {
            d.addEventListener("DOMContentLoaded", f, false);
        } else { f(); }
    })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/32948409" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->




    

        <script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5977b23b80bb1d0011ab6d8a&product=sticky-share-buttons"></script>
    


  </body>
</html>
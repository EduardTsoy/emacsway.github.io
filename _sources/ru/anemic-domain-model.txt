
Про Anemic Domain Model
=======================

.. post:: Jan 04, 2018
   :language: ru
   :tags: ORM, DataMapper, DB, SQL, Model, DDD, Repository
   :category:
   :author: Ivan Zakrevsky


Время от времени в кругу моих знакомых регулярно поднимается вопрос о том, что Anemic Domain Model - никакой вовсе и не антипаттерн, и в качестве аргументов приводятся ссылки на статью "The Anaemic Domain Model is no Anti-Pattern, it’s a SOLID design" [#fnadminapen]_.
После очередного упоминания этой статьи я решил об этом написать.

Я не знаю, читал ли автор той статьи весь список перечисленной внизу нее литературы, потому что в этом списке присутствует книга "Martin, Robert C. Agile software development: principles, patterns, and practices. Prentice Hall PTR, 2003".

А эта книга дает, на мой взгляд, лучшее представление о том, что делают методы объекта: они Внедряют Зависимости (Dependency Injection), что делает полиморфизм возможным!
Я всем советую сперва прочесть эту книгу (именно книгу в оригинале, а не краткие выдержки из Википедии), прежде чем читать указанную статью.
Как минимум, просмотрите хотя бы этот видеоролик: "`Bob Martin SOLID Principles of Object Oriented and Agile Design <https://www.youtube.com/watch?v=TMuno5RZNeE>`__".

Я не думаю, что исключение внедрения зависимостей (Dependency Injection) на уровне объекта будет соответствовать пятому принципу "D" в SOLID, а лишение объекта полиморфизма (да еще и в условиях отсутствия `Множественной Диспетчеризации <https://en.wikipedia.org/wiki/Multiple_dispatch>`__) будет соответствовать третьему принципу "L" в SOLID.
В таком случае внедрять зависимости и обеспечивать полиморфизм придется вручную, фактически превращая программу из объектно-ориентированной в процедурную.

Нужно заметить, что на этом месте многие начинают говорить о превосходствах функционального программирования, не понимая отличий межу функциональным программированием и процедурным.
Если говорить о превосходствах функционального программирования, то Роберт Мартин уже все сказал в статье "`OO vs FP <http://blog.cleancoder.com/uncle-bob/2014/11/24/FPvsOO.html>`__".

Но вернемся к обсуждаемой статье.
Я так и не смог найти имя автора той статьи на том сайте.
Нечего и говорить, что это - весомый аргумент для авторитета статьи, которая с легкостью берется опровергать статью Мартина Фаулера(!) "`Anemic Domain Model <https://www.martinfowler.com/bliki/AnemicDomainModel.html>`__".
Создается впечатление, что подобные статьи - просто способ привлечь внимание к ресурсу, используя общественную резонансность скандальных утверждений.

Автор демонстрирует отсутствие четкого понимания различий между:

#. Логикой уровня приложения
#. Бизнес-логикой (причем, следует отличать предметно-ориентированную бизнес-логику от бизнес-логики, зависящей от приложения)
#. Обязанностью доступа к данным (что не является бизнес-логикой), иногда именуемой слоем данных

Указанная статья целиком построена на ошибках автора в проектировании.
В своем примере он рассматривает вместо бизнес-логики - обязанность доступа к данным (да еще и в виде Active Record(!)).
Жаль, что в его списке литературы нет книги "Clean Code" by Robert C. Martin, в которой рассказывается, как для разделения служебной логики и бизнес-логики вот уже более 10 лет используется Cross-Cutting Concerns.

Уникальная способность автора всунуть в доменную модель обязанности слоя Data Mapper и Repository, - это, действительно, достаточно весомый аргумент для того, чтобы автор не наделял доменную модель вообще никакими обязанностями.
К тому же Service Layer не предназначен для обязанностей предметно-ориентированной бизнес-логики.
Мы можем вынести ее куда угодно, в Visitor, Strategy, Delegate, но мы должны соблюдать принципы расслоения системы, и не использовать слой уровня логики приложения для обязанностей слоя предметной области.

Для того чтобы завуалировать неразбериху, автор вводит лишнее понятие Rich Domain Model, вводя тем самым читателя в заблуждение относительно присутствия некой дифференцированности в реализации Domain Model.
Нет никаких Rich Domain Model.
Есть Domain Model (объект моделирующий поведение объекта реального мира (предметной области)), а есть Anemic Domain Model (т.е. структура данных, выраженная объектами без поведения).

Все что не относится к логике предметной области, - это новая обязанность, которая должна быть вынесена за пределы Domain Model, или, по крайней мере, не рассматриваться как бизнес-логика, если Domain Model реализована в виде паттерна Active Record (как в той статье).

Domain Model может быть представлена в виде агрегата, т.е. композиции связанных объектов, что характерно для DDD и NoSQL.
Domain Model может иметь методы, изменяющие ее состояние или композицию, но она не должна заботиться о сохранении этой композиции в базе данных.
Предположим, Вы осознали что NoSQL-хранилище Вам подходит лучше, чем RDBMS, и решили заменить реализацию класса ответственного за сохранение объекта.
NoSQL хранилища построены вокруг идеи агретата, что позволяет, в определенной мере, избавиться от реляционных связей и упростить шардинг.
Границами транзакции NoSQL-хранилища являются границы агрегата.
Если у Вас детали реализации сохранения агрегата скрыты за интерфейсом ответственного за это объекта (обычно это Repository + DataMapper), то такой рефакторинг не затронет реализацию самой Доменной Модели.

Иногда случается, что Domain Model не представлена агрегатом, но должна знать о связанных объектах для реализации своей бизнес-логики.
В Python для этого обычно используются дескрипторы, которые осуществляют ленивый доступ к связанным объектам.
И хотя это обычно никак не усложняет тестирование (потому что дескрипторы обычно кэшируют в памяти явно установленные клиентом объекты), но все-таки привносит служебную логику доступа к данным в Domain Model, пусть она и хорошо инкапсулирована за интерфейсом дескриптора.
Более чистым решением является наложение аспекта на экземпляр Domain Model сразу после его создания.
Тогда при тестировании Вы просто подменяете реализацию этого аспекта.

Частично эту тему я уже затрагивал в статьях:

- ":doc:`storm-orm`"
- ":doc:`javascript-and-repository-pattern`"
- ":doc:`service-layer`"

Да, бывают случаи, когда мы должны использовать структуры данных вместо объектов.
Но это не имеет никакого отношения к тому, что написал автор.

Автор просто пишет о том, как писать процедурные программы в Объектно-Ориентированных языках.

Попробуйте реализовать в таком стиле паттерн `Class Table Inheritance <https://martinfowler.com/eaaCatalog/classTableInheritance.html>`__ с достаточно богатой бизнес-логикой, и вы поймете все недостатки Anemic Domain Model.

В определенной мере, затрагиваемая тема относится и к этой презентации \https://www.destroyallsoftware.com/talks/boundaries .

.. rubric:: Footnotes

.. [#fnadminapen] "The Anaemic Domain Model is no Anti-Pattern, it’s a SOLID design" \https://blog.inf.ed.ac.uk/sapm/2014/02/04/the-anaemic-domain-model-is-no-anti-pattern-its-a-solid-design/ (перевод на русский "Анемичная модель предметной области — не анти-шаблон, а архитектура по принципам SOLID" \https://habrahabr.ru/post/346016/ )

.. update:: Jan 04, 2018

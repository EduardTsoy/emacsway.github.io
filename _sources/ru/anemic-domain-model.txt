
Про Anemic Domain Model
=======================

.. post:: Jan 04, 2018
   :language: ru
   :tags: ORM, DataMapper, DB, SQL, Model, DDD, Repository
   :category:
   :author: Ivan Zakrevsky


Время от времени в кругу моих знакомых регулярно поднимается вопрос о том, что Anemic Domain Model - никакой вовсе и не антипаттерн, и в качестве аргументов приводятся ссылки на статью "The Anaemic Domain Model is no Anti-Pattern, it’s a SOLID design" [#fnadminapen]_.
После очередного упоминания этой статьи я решил об этом написать.

Я не знаю, читал ли автор той статьи весь список перечисленной внизу нее литературы, потому что в этом списке присутствует книга "Martin, Robert C. Agile software development: principles, patterns, and practices. Prentice Hall PTR, 2003".

А эта книга дает, на мой взгляд, лучшее представление о том, что делают методы объекта: `они Внедряют Зависимости (Dependency Injection) <https://youtu.be/TMuno5RZNeE?t=33m30s>`__, что делает полиморфизм возможным!
Я всем советую сперва прочесть эту книгу (именно книгу в оригинале, а не краткие выдержки из Википедии), прежде чем читать указанную статью.
Как минимум, просмотрите хотя бы этот видеоролик: "`Bob Martin SOLID Principles of Object Oriented and Agile Design <https://www.youtube.com/watch?v=TMuno5RZNeE>`__".

Я не думаю, что исключение внедрения зависимостей (Dependency Injection) на уровне объекта будет соответствовать пятому принципу "D" в SOLID, а лишение объекта полиморфизма (да еще и в условиях отсутствия `Множественной Диспетчеризации <https://en.wikipedia.org/wiki/Multiple_dispatch>`__) будет соответствовать третьему принципу "L" в SOLID.
В таком случае внедрять зависимости и обеспечивать полиморфизм придется вручную, фактически превращая программу из объектно-ориентированной в процедурную.

Нужно заметить, что на этом месте многие начинают говорить о превосходствах функционального программирования, не понимая отличий межу функциональным программированием и процедурным.
Если говорить о превосходствах функционального программирования, то Роберт Мартин уже все сказал в статье "`OO vs FP <http://blog.cleancoder.com/uncle-bob/2014/11/24/FPvsOO.html>`__".

Но вернемся к обсуждаемой статье.
Я так и не смог найти имя автора той статьи на том сайте.
Нечего и говорить, что это - весомый аргумент для авторитета статьи, которая с легкостью берется опровергать статью Мартина Фаулера(!) "`Anemic Domain Model <https://www.martinfowler.com/bliki/AnemicDomainModel.html>`__".
Создается впечатление, что подобные статьи - просто способ привлечь внимание к ресурсу, используя общественную резонансность скандальных утверждений.

Автор демонстрирует отсутствие четкого понимания различий между:

#. Логикой уровня приложения
#. Бизнес-логикой (причем, следует отличать предметно-ориентированную бизнес-логику от бизнес-логики, зависящей от приложения)
#. Обязанностью доступа к данным (что не является бизнес-логикой), иногда именуемой слоем данных

Указанная статья целиком построена на ошибках проектирования.
В своем примере он рассматривает вместо бизнес-логики - обязанность доступа к данным (да еще и в виде Active Record(!)).
Жаль, что в его списке литературы нет книги "Clean Code" by Robert C. Martin, в которой рассказывается, как для разделения служебной логики и бизнес-логики вот уже более 10 лет используется Cross-Cutting Concerns.

Уникальная способность автора всунуть в доменную модель обязанности слоя Data Mapper и Repository, - это, действительно, достаточно весомый аргумент для того, чтобы автор не наделял доменную модель вообще никакими обязанностями.
К тому же Service Layer не предназначен для обязанностей предметно-ориентированной бизнес-логики.
Мы можем вынести ее куда угодно, в Visitor, Strategy, Wrapper, Delegate, но мы должны соблюдать принципы расслоения системы, и не использовать слой уровня приложения для обязанностей слоя предметной области.

Для того чтобы завуалировать неразбериху, автор вводит лишнее понятие Rich Domain Model, вводя тем самым читателя в заблуждение относительно присутствия некой дифференцированности в реализации Domain Model.
Нет никаких Rich Domain Model.
Есть Domain Model (объект моделирующий поведение объекта реального мира (предметной области)), а есть Anemic Domain Model (т.е. структура данных, выраженная объектами без поведения).

Все что не относится к логике предметной области, - это новая обязанность, которая должна быть вынесена за пределы Domain Model, или, по крайней мере, не рассматриваться как бизнес-логика, если Domain Model реализована в виде паттерна Active Record (как в той статье).

Очень часто можно наблюдать разбухшие модели, которые выполняют очень много несвойственных ее предметной области обязанностей, в т.ч. и уровня приложения (управление транзакциями, проверка привилегий и т.п.).
Domain Model должна моделировать только поведение объекта предметной области (реального мира).
Если Domain Model имеет несколько десятков методов, которые не выражают поведение объекта реального мира, не имеют общего применения, а используются только одним клиентом, то мы должны их разместить либо непосредственно внутри клиента, либо в классе, который обслуживает клиента (для обслуживания клиентов уровня приложения существует Sevice Layer, для обслуживания клиентов уровня предметной области и выравнивания интерфейсов существует паттерн Wrapper).
Более подробно эта тема уже рассматривалась в статье ":doc:`service-layer`".

Domain Model может быть представлена в виде агрегата, т.е. композиции связанных объектов, что характерно для DDD и NoSQL.
Domain Model может иметь методы, изменяющие ее состояние или композицию, но она не должна заботиться о сохранении этой композиции в базе данных.
Предположим, Вы осознали что NoSQL-хранилище Вам подходит лучше, чем RDBMS, и решили заменить реализацию класса ответственного за сохранение объекта.
С точки зрения архитектуры, база данных - это IO-устройство, от которого приложение стремится быть независимым.
NoSQL хранилища построены вокруг идеи агрегата, что позволяет, в определенной мере, избавиться от реляционных связей и упростить шардинг.
Границами транзакции NoSQL-хранилища являются границы агрегата.
Если у Вас детали реализации сохранения агрегата скрыты за интерфейсом ответственного за это объекта (обычно это Repository + DataMapper), то такой рефакторинг не затронет реализацию самой Доменной Модели.
Если Вы вынуждены изменять реализацию Domain Model, то это значит, что Ваша программа не имеет независимости от IO-устройства, что нарушает Single Responsibility Principle (в виде Code Smell "Shotgun Surgery").

Иногда случается, что Бизнес-Логика Доменной Модели нуждается в доступе к экземпляру связанной Доменной Модели, или даже в доступе к корню другого Агрегата.
Недостаточное понимание способов разделения политики разных уровней (Бизнес-Логики и Логики Доступа к Данным) часто приводит к оправданию Anemic Domain Model.
Между тем, существует целый :ref:`ряд способов решения этой проблемы <domain-model-relationship-ru>`.

Эта тема уже затрагивалась в статьях:

- ":doc:`javascript-and-repository-pattern`"
- ":doc:`service-layer`"
- ":doc:`storm-orm`"

Вы можете подумать, зачем возиться с разделением обязанностей?
Ведь можно просто откатиться до времен процедурного программирования (или даже до ассемблера) и не использовать ООП вовсе.
Но что делает ООП?
Оно укрощает сложность кода.
Оно удешевляет процесс разработки.
Оно позволяет поддерживать стоимость изменения программы низкой.
Это - эволюция.
Благодаря этому мы можем создавать программы нового масштаба за те же финансовые ресурсы.

Помните, когда Мартину Фаулеру сказали, что гибкое проектирование невозможно, потому что схему базы данных сложно изменить, а значит, ее нужно проектировать заблаговременно, то `Мартин Фаулер ответил <https://youtu.be/VjKYO6DP3fo?t=16m11s>`__, что если схему базы сложно изменить, значит мы должны подумать о том, как можно сделать процесс миграций проще?
Так появился механизм миграций базы данных, и гибкое проектирование Agile стало возможным.
А что делает Agile методология?
Она позволяет сохранять стоимость изменения программы низкой, благодаря чему программу становится легко адаптировать под изменяющиеся бизнес-требования рынка.
Вы можете представить себе Мартина Фаулера, который сказал бы, что Agile - это плохо, потому что схему базы данных сложно изменить?

Ключевой признак плохой архитектуры - это ее зависимость от деталей реализации.
Если Вы принимаете проектные решения (а тем более - парадигму) в угоду реализации, то это говорит о проблемах проектирования.
Это - зависимость.
Архитектура должна указывать реализацию, а не подстраиваться под нее.

Да, бывают случаи, когда мы должны использовать структуры данных вместо объектов.
Но это не имеет никакого отношения к тому, что написал автор.

Автор просто пишет о том, как писать процедурные программы в Объектно-Ориентированных языках.

Попробуйте реализовать в таком стиле паттерн `Class Table Inheritance <https://martinfowler.com/eaaCatalog/classTableInheritance.html>`__ для коллекции полиморфных объектов с достаточно богатой бизнес-логикой, и вы поймете все недостатки Anemic Domain Model.
То же самое справедливо и к случаю использования паттерна `Special Case <https://martinfowler.com/eaaCatalog/specialCase.html>`__, известного так же как метод рефакторинга `Introduce Null Object <https://www.refactoring.com/catalog/introduceNullObject.html>`__.
Смотрите так же `Replace Conditional with Polymorphism <https://www.refactoring.com/catalog/replaceConditionalWithPolymorphism.html>`__, `Replace Type Code With Polymorphism <https://www.refactoring.com/catalog/replaceTypeCodeWithPolymorphism.html>`__ и `Replace Type Code with State/Strategy <https://www.refactoring.com/catalog/replaceTypeCodeWithStateStrategy.html>`__ (желательно смотреть информацию в книге, номер страницы указан на страницах онлайн-каталога по ссылкам).

.. В определенной мере, затрагиваемая тема относится и к этой презентации \https://www.destroyallsoftware.com/talks/boundaries .

.. rubric:: Footnotes

.. [#fnadminapen] "The Anaemic Domain Model is no Anti-Pattern, it’s a SOLID design" \https://blog.inf.ed.ac.uk/sapm/2014/02/04/the-anaemic-domain-model-is-no-anti-pattern-its-a-solid-design/ (перевод на русский "Анемичная модель предметной области — не анти-шаблон, а архитектура по принципам SOLID" \https://habrahabr.ru/post/346016/ )
.. [#fnpoeaa] "Patterns of Enterprise Application Architecture" by Martin Fowler, David Rice, Matthew Foemmel, Edward Hieatt, Robert Mee, Randy Stafford

.. update:: May 16, 2018
